use crate::common::{assertions::RpcErrorAssertions, *};
use jsonrpsee::rpc_params;
use solana_sdk::signer::Signer;
use solana_system_interface::instruction::transfer;
use spl_associated_token_account_interface::address::get_associated_token_address;
use spl_token_interface::instruction as token_instruction;

#[tokio::test]
async fn test_fee_payer_as_sol_transfer_source() {
    let ctx = TestContext::new().await.expect("Failed to create test context");
    let setup = TestAccountSetup::new().await;

    let fee_payer_pubkey = FeePayerTestHelper::get_fee_payer_pubkey();

    let large_sol_transfer = transfer(
        &fee_payer_pubkey,
        &setup.sender_keypair.pubkey(),
        1_000_000, // 0.001 SOL in lamports
    );

    let malicious_tx = ctx
        .transaction_builder()
        .with_fee_payer(fee_payer_pubkey)
        .with_spl_payment(
            &setup.usdc_mint.pubkey(),
            &setup.sender_keypair.pubkey(),
            &fee_payer_pubkey,
            10, // Small payment: 0.00001 USDC tokens (much less than 0.001 SOL value)
        )
        .with_instruction(large_sol_transfer)
        .build()
        .await
        .expect("Failed to create transaction with fee payer as SOL source");

    let result =
        ctx.rpc_call::<serde_json::Value, _>("signTransaction", rpc_params![malicious_tx]).await;

    match result {
        Err(error) => {
            error.assert_contains_message("Insufficient token payment");
        }
        Ok(_) => panic!("Expected error for fee payer as SOL transfer source"),
    }
}

#[tokio::test]
async fn test_fee_payer_as_spl_transfer_source() {
    let ctx = TestContext::new().await.expect("Failed to create test context");
    let setup = TestAccountSetup::new().await;

    let fee_payer_pubkey = FeePayerTestHelper::get_fee_payer_pubkey();

    let fee_payer_token_account =
        get_associated_token_address(&fee_payer_pubkey, &setup.usdc_mint.pubkey());
    let sender_token_account =
        get_associated_token_address(&setup.sender_keypair.pubkey(), &setup.usdc_mint.pubkey());

    // Mint tokens for the fee payer
    setup
        .mint_tokens_to_account(&fee_payer_token_account, 100_000)
        .await
        .expect("Failed to mint tokens");

    // Run the test transaction
    let large_token_transfer = token_instruction::transfer(
        &spl_token_interface::id(),
        &fee_payer_token_account,
        &sender_token_account,
        &fee_payer_pubkey,
        &[&fee_payer_pubkey],
        100_000,
    )
    .expect("Failed to create token transfer instruction");

    let malicious_tx = ctx
        .transaction_builder()
        .with_fee_payer(fee_payer_pubkey)
        .with_spl_payment(
            &setup.usdc_mint.pubkey(),
            &setup.sender_keypair.pubkey(),
            &fee_payer_pubkey,
            1_000, // Smaller than the 100,000 USDC transfer
        )
        .with_instruction(large_token_transfer)
        .build()
        .await
        .expect("Failed to create transaction with fee payer as USDC source");

    let result =
        ctx.rpc_call::<serde_json::Value, _>("signTransaction", rpc_params![malicious_tx]).await;

    match result {
        Err(error) => {
            error.assert_contains_message("Insufficient token payment");
        }
        Ok(_) => panic!("Expected error for fee payer as USDC transfer source"),
    }
}
